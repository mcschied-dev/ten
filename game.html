<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>BumbleBees</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(
            0deg,
            rgba(76,168,106,1) 0%,
            rgba(138,199,244,1) 100%
            );
            filter: saturate(1.1) brightness(1.05);
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 100vh;
            overflow: hidden;
        }

        #game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 20px;
        }

        #title {
            color: white;
            font-size: 3em;
            font-weight: 700;
            text-shadow: 0 4px 8px rgba(0,0,0,0.3);
            margin: 0;
        }

        canvas {
            border-radius: 12px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.4);
            display: block;
            width: 1024px;
            height: 575px;
        }

        #loading {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            text-align: center;
            z-index: 1000;
            background: rgba(0,0,0,0.9);
            padding: 40px 60px;
            border-radius: 16px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.5);
            min-width: 400px;
        }

        #loading.hidden {
            display: none;
        }

        #loading-title {
            font-size: 32px;
            margin-bottom: 20px;
            font-weight: bold;
        }

        #loading-status {
            font-size: 16px;
            margin-bottom: 15px;
            color: #aaa;
            min-height: 20px;
        }

        #progress-container {
            width: 100%;
            height: 30px;
            background: rgba(255,255,255,0.1);
            border-radius: 15px;
            overflow: hidden;
            margin: 20px 0;
            border: 2px solid rgba(255,255,255,0.2);
        }

        #progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #667eea 0%, #764ba2 100%);
            border-radius: 15px;
            transition: width 0.3s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            color: white;
            font-size: 14px;
            font-weight: bold;
        }

        .loader {
            border: 5px solid #f3f3f3;
            border-top: 5px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 20px auto 0;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        #error {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: #f8d7da;
            color: #721c24;
            padding: 30px;
            border-radius: 12px;
            border: 2px solid #f5c6cb;
            max-width: 500px;
            text-align: center;
            z-index: 1001;
        }

        #error.visible {
            display: block;
        }

        .info {
            color: white;
            text-align: center;
            margin-top: 20px;
            font-size: 0.9em;
            opacity: 0.8;
        }
    </style>
</head>
<body>
    <div id="loading">
        <div id="loading-title">üêù BumbleBees</div>
        <div id="loading-status">Initializing...</div>
        <div id="progress-container">
            <div id="progress-bar">0%</div>
        </div>
        <div class="loader"></div>
    </div>

    <div id="error">
        <h3>Failed to load game</h3>
        <p id="error-message"></p>
    </div>

    <div id="game-container">
    
        <canvas id="glcanvas" width="1024" height="575" tabindex="0" style="image-rendering: pixelated;"></canvas>
        <div class="info">
            Use Arrow Keys to move | Space to shoot | Press Space to start
        </div>
    </div>

    <script src="https://not-fl3.github.io/miniquad-samples/mq_js_bundle.js"></script>
    <script>
        // Loading progress tracker
        const loadingSteps = {
            'Starting BumbleBees game (WASM)': 5,
            'Initializing game...': 10,
            'Game::new() - Starting resource load': 15,
            'Loading bg_main.png...': 25,
            'Loaded bg_main.png successfully': 35,
            'Loading audio files...': 45,
            'All audio loaded': 85,
            'Game::new() - All resources loaded, creating game state': 95,
            'Game initialized successfully!': 100
        };

        function updateLoadingProgress(message) {
            const statusEl = document.getElementById('loading-status');
            const progressBar = document.getElementById('progress-bar');

            if (statusEl && progressBar) {
                // Update status text
                statusEl.textContent = message;

                // Update progress bar
                const progress = loadingSteps[message] || progressBar.style.width;
                if (typeof progress === 'number') {
                    progressBar.style.width = progress + '%';
                    progressBar.textContent = progress + '%';
                }

                // Hide loading screen when complete
                if (progress === 100) {
                    setTimeout(() => {
                        const loadingEl = document.getElementById('loading');
                        if (loadingEl) {
                            loadingEl.style.display = 'none';
                        }
                    }, 500);
                }
            }
        }

        // Global function that WASM can call directly
        window.update_loading_progress = function(msg_ptr, msg_len) {
            // Read string from WASM memory
            const bytes = new Uint8Array(wasm_memory.buffer, msg_ptr, msg_len);
            const message = new TextDecoder().decode(bytes);

            console.log("Loading progress:", message);
            updateLoadingProgress(message);
        };
    </script>
    <script>
        // localStorage bridge for WASM
        // Global references that will be set by the plugin
        var wasmMemory = null;
        var wasmExports = null;
        var stringCache = [];
        var memoryAllocatorOffset = 2000000; // Start allocation at 2MB
        var totalAllocated = 0; // Track total allocated memory
        const MAX_TOTAL_ALLOCATION = 10 * 1024 * 1024; // 10MB total cap

        // Try to capture WASM memory if not already available
        function tryCaptureMemory() {
            if (wasmMemory) return true;

            // Try all possible ways to get memory
            if (typeof wasm_exports !== 'undefined' && wasm_exports.memory) {
                wasmMemory = wasm_exports.memory;
                return true;
            }
            if (typeof wasm !== 'undefined') {
                if (wasm.memory) {
                    wasmMemory = wasm.memory;
                    return true;
                }
                if (wasm.instance && wasm.instance.exports && wasm.instance.exports.memory) {
                    wasmMemory = wasm.instance.exports.memory;
                    return true;
                }
            }
            // Try GL object which miniquad uses
            if (typeof GL !== 'undefined' && GL.context && GL.context.GLctx && GL.context.GLctx.canvas) {
                // Check if there's a WASM instance attached
                const canvas = GL.context.GLctx.canvas;
                if (canvas._wasmModule && canvas._wasmModule.exports && canvas._wasmModule.exports.memory) {
                    wasmMemory = canvas._wasmModule.exports.memory;
                    return true;
                }
            }

            return false;
        }

        // Helper to read C string from WASM memory
        function readCString(ptr) {
            if (!ptr) return null;

            // Try to capture memory if we don't have it yet
            if (!wasmMemory && !tryCaptureMemory()) {
                return null;
            }

            try {
                const memory = new Uint8Array(wasmMemory.buffer);
                let end = ptr;
                while (end < memory.length && memory[end] !== 0) {
                    end++;
                }

                if (end >= memory.length) {
                    return null;
                }

                const bytes = memory.subarray(ptr, end);
                return new TextDecoder('utf-8').decode(bytes);
            } catch (e) {
                return null;
            }
        }

        // Allocate string in WASM memory using bump allocator
        function allocateString(str) {
            if (!str) return 0;

            // Try to capture memory if we don't have it yet
            if (!wasmMemory && !tryCaptureMemory()) {
                return 0;
            }

            try {
                const encoder = new TextEncoder();
                const bytes = encoder.encode(str);
                const requiredSize = bytes.length + 1; // +1 for null terminator

                // Check total allocation limit
                if (totalAllocated + requiredSize > MAX_TOTAL_ALLOCATION) {
                    return 0; // Reject to prevent memory exhaustion
                }

                // Check if we need to grow memory
                if (memoryAllocatorOffset + requiredSize > wasmMemory.buffer.byteLength) {
                    const pagesNeeded = Math.ceil((memoryAllocatorOffset + requiredSize - wasmMemory.buffer.byteLength) / 65536);
                    // Limit growth to prevent excessive memory usage
                    if (pagesNeeded > 4) { // Max 256KB growth at once
                        console.warn("WASM: String too large for allocation, skipping");
                        return 0;
                    }
                    wasmMemory.grow(pagesNeeded);
                }

                const baseAddr = memoryAllocatorOffset;
                const memory = new Uint8Array(wasmMemory.buffer);

                // Copy string bytes
                memory.set(bytes, baseAddr);
                // Null terminate
                memory[baseAddr + bytes.length] = 0;

                // Store in cache for cleanup reference
                stringCache.push({
                    addr: baseAddr,
                    size: requiredSize,
                    str: str
                });

                // Advance allocator
                memoryAllocatorOffset += requiredSize;

                // Track total allocation
                totalAllocated += requiredSize;

                // Align to 4-byte boundary for better performance
                memoryAllocatorOffset = (memoryAllocatorOffset + 3) & ~3;

                return baseAddr;
            } catch (e) {
                console.error("WASM: Failed to allocate string:", e);
                return 0;
            }
        }

        // localStorage get function
        window.js_localstorage_get = function(key_ptr) {
            try {
                const key = readCString(key_ptr);
                if (!key) return 0;

                const value = localStorage.getItem(key);
                if (value === null) return 0;

                return allocateString(value);
            } catch (e) {
                return 0;
            }
        };

        // localStorage set function
        window.js_localstorage_set = function(key_ptr, value_ptr) {
            try {
                const key = readCString(key_ptr);
                const value = readCString(value_ptr);

                if (!key || value === null) return;

                localStorage.setItem(key, value);
            } catch (e) {
                // Silent fail
            }
        };

        // Free string and clean up cache
        window.js_free_string = function(ptr) {
            if (!ptr) return;

            // Remove from cache
            const index = stringCache.findIndex(entry => entry.addr === ptr);
            if (index >= 0) {
                stringCache.splice(index, 1);
            }

            // Note: We don't actually free memory in WASM, but we could reset
            // the allocator if all strings are freed (cache becomes empty)
            if (stringCache.length === 0) {
                memoryAllocatorOffset = 2000000; // Reset to start
            }
        };

        // Register plugin to inject functions and capture memory
        miniquad_add_plugin({
            register_plugin: function(importObject) {
                if (!importObject.env) {
                    importObject.env = {};
                }

                // Inject our functions
                importObject.env.js_localstorage_get = window.js_localstorage_get;
                importObject.env.js_localstorage_set = window.js_localstorage_set;
                importObject.env.js_free_string = window.js_free_string;
                importObject.env.update_loading_progress = window.update_loading_progress;
            },

            on_init: function() {
                // Try to capture memory
                tryCaptureMemory();
            },

            update: function() {},
            draw: function() {},
            ui: function() {},
            resize: function() {},
            mouse_down: function() {},
            mouse_up: function() {},
            mouse_move: function() {},
            raw_mouse_move: function() {},
            char_event: function() {},
            key_down: function() {},
            key_up: function() {},
            quit_requested_event: function() {},
        });

        // The miniquad bundle will automatically call load() and start the game
        window.addEventListener('DOMContentLoaded', function() {
            updateLoadingProgress('Initializing...');

            const canvas = document.getElementById('glcanvas');

            // Automatically focus the canvas when page loads
            setTimeout(function() {
                canvas.focus();
            }, 500);

            // Re-focus canvas when clicked
            canvas.addEventListener('click', function() {
                canvas.focus();
            });

            // Re-focus canvas when mouse enters
            canvas.addEventListener('mouseenter', function() {
                canvas.focus();
            });

            // Call load function from mq_js_bundle
            if (typeof load === 'function') {
                load("ten.wasm?v=" + Date.now());
                // Loading screen will be hidden automatically when game reaches 100%
            } else {
                document.getElementById('loading').innerHTML = '‚ùå Failed to load miniquad bundle';
            }
        });
    </script>
</body>
</html>
